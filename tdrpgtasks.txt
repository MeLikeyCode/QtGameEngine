===TASKS===-----------------DONE
Allow an Entity to quickly swap its movment behavior
-an Entity can be AI or Player controlled
-if it is player controlled, its movePlayerControlled() function will be executed
    -this function will move the Entity 1 step closer in response to the current keys being pressed
-if it is AI controlled, TODO will figure this out later
-encapsulate movement behaviors in classes
-an entity has a MovementBehavior


===TASK===----------------DONE
An entity should have two move functions
    -movePlayerControlled() // fires when entity is player controlled - moves in response to input
    -moveAIControlled() // fiers when entity is AI controlled - moves in response to its own thinking
If the entity isPlayerControlled(), its movePlayerControlled() function should executed, other wise its moveAIControlled()


===TASK===---------------DONE
Test to see if you can dynamically set/unset an entity to be controlled by player/ai
-how:connect to right click of mouse in game

===TASK===------------DONE
An entity that is player controlled should be able to dynamically swap the way it moves (up/down relative to facing, or relative to screen? etc...)
Right now:
    -if an entity isPlayerControlled(), its moveStepPlayerControlled() function will periodically executed
    -this function has the code that will move the enity in response to keyboard/mouse events
    -i need to take this code out and put it in a class that provides a moveStep() function
        -this class points to an entity
        -calling its moveStep() will operate on that entity
     -i can make anotehr class that also provides a moveStep() function but moves in a diff way (still has an entity ptr)
SO:
    -need interface PlayerControlledMoveBehavior w functions:
        -setEntity()
        -moveStep() // when called moves the entity according to logic of this MoveBehavior
     -need two classes that implement this interface
        -one that moves in the way currently
        -another that moves in relative to screen coordinates
        
===TASK===--------------DONE
Create a new PlayerControlledMoveBehavior called MoveRelativeToScreen that moves the entity relative to 
the screen.

===TASK===--------------DONE
A Weapon should not have all the qualities of an advanced entity such as path finding and such. You should not be able even call this type of functionality on a Weapon. Therefore I must extract the base functionality and put it in an Entity class. Advanced entities can subclass this (such as a Character entity, with pathfinding abilities). Weapon class can also subclass this and have its own abilities (such as attack).
Thinking stack:
-a MeleeWeapon should not have all the behaviors of an Entity (such as moveTo())
-then it should not inherit Entity, why is it inheriting the entity?
-to be able to use the Entity parent/child system
-entity parent/child system should be implemented at the "Entity" level (Character and Weapon should inherit)
SO:
    -need a bare Entity class where parent/child system is implemented ----- done
        -when parent moves, children move
        -when parent rotates, children rotates
        -when parent dies, children are killed
    -need a 
SO:
    -need an need a dynamic entity that can move on its own or in response to user control

    
===TASK===--------------DONE
Improve spear system
-should only do damage if it is hitting while going forward - done
-should go back as soon as hitting something - done
-should have a length variable - done
-should have a width variable - done
-should have an attachment point variable - done
-should have a thrust speed and thrust distance variable - done

===TASK===--------------DONE
-remove attackSwing(), attackThrust(), etc...from MeleeWeapon class and just give it a attack() method - done
-the attack() method should smartly determine whether it wants to swing, thrust, etc...

===TASK===--------------DONE
-download/polish/import axe picture - done
create basic Axe class (skeletal framework, copy spear and then edit accordingly)

===TASK=== --------------DONE
Plan a swinging weapon (Axe class)
-should have a set swingClockWise(), set counterClockWise()
-Axe::attack()
    -should attack by swinging
    -should check for collision at "point"
    -each step, should move in the direction of clock or counter clock wise

===TASK===
Fix Axe swing animation --------DONE

===TASK===----------DONE
Move function documentation from the .cpp files to the .h files.
I changed my mind. Since I will be releasing the source of this framework, the user can easily browse through function declarations and "follow" the ones he/she would like to see the documentation for.Additionally, putting the docuementation 
in the source file is advantageous because the public api docuementation is close to an additional source of docuementation - the code itself (as well as any comments around it).

===TASK===----------DONE
I want a MusicPlayer class. Internally it has a QMediaPlayer. It can take a list of songs and play them in order or in shuffel.
It can loop a song a certain number of times or infinitely.

===TASK===-------------DONE
Move common behavior of Axe and Spear into a base class.
Common behavior:
setTip()
resetTip()
tip()
setLength()
setWidth()
width()

===TASK===---------------DONE
Give DynamicEntitys an Inventory of Items. A DynamicEntity can equip() certain Items (EquipableItems) in its Inventory. When an Item is equipped, that Item remembers who it is equiped by, and it will do its effect to the benefit of that DynamicEntity. Furthermore, Items know which Inventory they are a part of, and an Inventory knows which DynamicEntity it is a part of, therefore essentially each Item will know whos Inventory they are a part of, thus they will give their effect to that DynamicEntity.

need the following classes:
Inventory
-entity()
Item
-inventory()
-charges()
-use()
-equip() // some items need to be told where to equip to (leftHand, rightHand, any namedPoint)

===TASK===----------------DONE
Implement equipment slot system:
-an Entity has a bunch of equipment slots
-when an EquipableItem is equiped at a certain slot, that slot gets filled (trying to equip to it again won't work)
-Entity needs to maintain a set of "slots"
-The Entity can use() the item at a certain slot (if an Item has be equipped at that slot) 


===TASK===-------------DONE
make a range weapon
|
V
- create a RangedWeapon class with an attack(point) virtual function
- create a RangedWeaponSlot class whos canEquip(Item) function returns true only for RangedWeaponSlot
- create a Bow class (concrete RangedWeapon) that shoots an arrow at the specified point
- create a Projectile base class
    -a projectile moves to a target
- create a StraightProjectile class that moves in a straight line till it reaches its target
- create a ZigzagProjectile that will zigzag to its target point
|
V----done
- create a Projectile class that
    - has a target point (QPointF)
    - has a set of entities that it will not damage
    - has a virtual step() function
    - has an int describing how often the step() function should be called
    - has a start() function that will connect timer and start calling step()
    
- create a StraightProjectile
    -inherits from Projectile
    - has a settable sprite
    - has a settable damage
    - step() - every step will move closer to point (which must be passed in constructr)
    
===TASK===----------DONE
Move ""setting the facing angle"" responsibility of a StraightProjectile to the StraightProjectile class itself

===TASK===-----------DONE
-entities should have a field of view  modeled as a triangle
-entities should be able to tell you the other entities in its field of view

===TASK===------------DONE
Test field of view for Entities
-one click should place entity
-the other click should tell you the number of things in view
-draw sides just to check
*debug: it doesn't work, find out why DynamicEntity::entitiesInFieldOfView() doesn't work?

===TASK===-----------DONE
Make Projectile system use strateg pattern rathern than inheretence
-a Projectile should have a ProjectileMoveBehavior that has a onStep() which defines how the projectile moves every step.
-a Projectile should have a ProjectileCollisionBehavior that has a onCollide(std::unordered_set<Entity> entities) function that determines the behavior of the projectile in response to colliding
-a Projectile should have a ProjectileRangeReachedBehavior that has a onRangeReached() that defines how the projectile responds to reaching its range.

-implement a ProjectileMoveBehaviorStraight
-implement a ProjectileCollisionBehaviorDamage
-implement a ProjectileRangeReachedBehaviorDestroy
-implment a ProjectileMoveBehaviorHoming
    -this algorithm is already defined in one of my classes
    -copy it from there 
    
===TASK===------------DONE
Create an Enemy that will continueously check his field of view, if someone not in his group enters, he will move to that 
position.
|
V
Enemy will have a function that will periodically check what is in his field of view, it will travers through them and if
the group doesnt match the Enemies, then it will move to the location of the entity and disconnect for a little while

===TASK===------------DONE
start: 830 pm
end:
When Enemy is moving to attack an entity, when it gets close enough (range of his default weapon), he will use his weapon.

subtasks
- all Weapons should have a castRange -- done
- MeleeWeapon and RangedWeapon should inherti from Weapon, which has an attack(point) abstract method -- done
    -MeleeWeapon will ignore the point
    -Ranged will use it
 -Weapon Slot that can house any Weapon (Melee or Ranged), will simplly call the attack of the weapon -- done
-move inventory/item/equipment responsibility from Entity to DynamicEntity -- done
-When a DynamicEntity equips a Weapon, if its the first, it should be the defaultWeapon.
-when enemy is moving towards its enemy, it should check if weapon is in range, if so, it should swing/attach it

===TASK===------done
When an Entity is added to a map
-all child entities should be added to map (if they are already not in the map, if in other map, should be removed from there and then added to new map)

===TASK=== --- done
-test if enemy works with other weapons
-spear? __ no
-axe? __ no

-spear and axe kill Enemy when it strikes

debugging
-the spear does not have a map to return via map() function
-when Enemy adds the spear to its inv in its constructor, the enemy has no map therefore the spear has no map either/
    -then why it shows up?
    
-when the enemy is added to map, all of its children are added also
-but the spear is not a child of the enemy

-Entity::setParentEntity() works imporperly
    -
    
===TASK=== ---- done
Entity::children() returns a reference to an internal collection
-have a addChild(), removeChild() member function
-search for all code that uses children(), replace it w one of above functions
-have children() return a read only list (copy)

===TASK===
Pathfinding algorithm should take place in another thread and call back when done (move like a dumbass till then)

===TASK===---------done
-entities move backward every once in a while
-this is probably because when the path is finally calculated in the other thread, the object has already moved forward,
so then when he gets the results, he starts going to the first point (which was at a previous place)

===TASK===-------done
Clean up/refactor movement system and async path finder
-see if movement is fast enough now - done (ok for now, can handle about 5-6 entiteis at same time)
-see if adding rocks in path still succesfully recalculates - done
-make sure after asyncshortestpathfinder finds path, it cleans up the worker and thread - done

===TASK===-----------DONE
GREAT IDEA
-DynamicEntitys should not auto recalculate path upon EACH move
-instead they should recalculate path only when "stuck"
-make it so that entities cannot go forward unless there is freedom in that cell (just like player controlled move does)
-when an entity has been "stuck" for x amount of time, it should recalculate path to its target!

===TASK===-----DONE
When a path is calculated from nodeN to the same nodeN, it should return a vector of 0, instead of just crashing.

===TASK===---------DONE
Implement "group" system
-each AI entity should have a groupId
-each AI entity should have a list of friend groups and  a list of enemy groups
-when an enemy group is in view, it should set it as its target
-when the enemy is out of view, it should stop pursueing (target=nullptr)
-when the pursuent (entity being purused) is dead, should stop pursueing (need to know when target entity dies)

todo:
-add groupID_ field to Entity

===TASK===--------------DONE
Every entity needs to have health.
Every entity needs to know what it can be damaged by and what it can't be damage by.
-entity can be damaged by only the following {}
-entity can be damaged by anything but the following {}
-anytime an entity attempts to deal damage to another entity (i.e. projectile to enemy), it should do so through Entity::attemptDamageTo(Entity* target)
*done, but need to make weapon use damage() rather than just deleteing what it touches <-- LEFT OVER

===TASK===---------DONE
Camera/move system
Game should be able to move the camera around the map
|
V
Game represents the game. Game has a Map. Game visualize a certain portion of the Map.
|
V
Game provides a function for setting the center of the camera at some point on the map
Game provides a function for moving the camera by a vector
Game provides a function for moving the camera up/down/left/right by a certain amount (specialization of previous problem)
|
V
Game::setCameraPos(QPoinF to); // sets the position of the camera (center the camera) to the specified point on the Map
Game::moveCamera(QVector2D byVector);
Game::moveCamUp(double by); // also down, left, right

===TASK===-------------DONE
-make terrain/map huge
-spawn player
-have camera follow player
    - in DynamiEntity's movement mode, if camerafolllow mode, move to player - done

===TASK===-------------done
Pathfinding needs to happen in another thread

===TASK===------------DONE
Old pathfinding is a bit too slow for all cases (useful in some - so still keep it around). Need to make an alternative.
|
V
When entity e is told to move to position p
-draw line from e to p, if there are no obsticles -> move straight
-if there are obsticles then calculate path

moveTo(Point p){
    // set target point
    
    // draw line, if no obsticles, take step towards point
    stepTowardsTarget()
    
    // if obsticles, pathfind (in current thread)
}

// yet another alternative Ai movement
*used A*, much faster

===TASK===----------DONE
The same entity can be in multiple lists, when its deleted from one list, its dangled in the other.
|
V
Every so often projectileA gets list of colliding units, goes through and deletes, some
Every so often projectileB gets list of colliding units (may have same stuff as list a)
Since projectileA deltes some, now projectileB has dangling pointers
|
V
Solution:
QPointer

===TASK===-------------DONE
Projectile system is a bit messed up. Projectiles move back and forth.

===TASK====---------DONE
Refactor
-look at one class at a time
-what happens if it dies?
-what happens if one of its pointers_ dies? does he clean dangling pointers?

-any excess "includes"? (forward declare instead)

done:
-AsyncShortestPathFinder
-Axe
-Bow
-CountExpiringTimer
-DynamicEntity
-Edge

// this was another task, merged it with above task
Go back and handle deleting/removing/clean up of all objects/classes
-when one enemy destroys another enemy, crashes
    -b/c the killer enemy still has a dangling reference to the killed enemy

solution: QObjects have a destroyed() signal that is emitted right before the object gets deleted. You should listen 
for this signal and respond appropriately to avoid dangling references.
-enemies should do this, when target_ is destroyed(), they should stop pursueing

===TASK===----------DONE
Research on C++ move ctor - done
Research why new should be decoupled from business logic (besides making classes testable)
Research if using static data/functions is something you should (almost) always avoid?

===TASK===---------DONE
I have
-entities that can see, move, have enemies, projectiles, pathfinding, sprites, camera movement, cam following, items

I feel like I need to improve the item system...let me review the inventory, item, equipment system

===TASK===------------DONE
complete item/inventory system
make a couple of examples items, place them on the ground, pick them up in your inventory, use them, drop them etc
|
V
design/plan gui for inventory
|
V
design/plan general gui system
|
V

====TASK===-----------DONE
compete item/inventory system
|
V
create an item that upon use will shoot out a fan of spears
|
V
create a NoTargetItem that on its use() will spawn a bunch of projectiles that go out in all directions

===TASK===------------DONE
Item system needs to be refactored a little bit
-specifically, the item drop/pick up, depends on making the item visible/invisible...this is a bad idea becaus, even when
invisible, entities can be damaged!

item system is comprised of the following classes:
Item abstract class and its concrete subclasses
Slot abstract class and concrete subclasses that can equip/unequip various item types
DynamicEntity which can have a bunch of Slots
Inventory which is a collection of Items (that can be added/removed from the inventory)
InventoryCell which visually represents an Item in an inventory and allows a) dropping it from inv and b) using it from inv
InventoryViewer which is a collection of InventoryCells. Inventory cells can be added/removed from it and it will update display.

===TASK===-------DONE
Implement a PointTargetItem and EntityTargetItem

PointTargetItem: -- DONE
Teleport
-teleports the owner to the specified location

EntityTargetItem:----DONE
push back
-pushes target entity back from owner

===TASK=== --------DONE
-implement mouse modes
-finish implementing PointTargetItem and EntityTargetItem

===TASK===------DONE
create a few concrete projectile classes that instantiate the correct respective behaviors
-create spearprojectile - done
-create a PlayerControlledMoveBehaviorSine(amplitude, period, range)

===TASK===-------DONE
Refactor recently added code (Item system in general)

    -setSize(int w, int h) should go in Entity (simply set the size of current frame and ALL pixmaps of all animations to size)

    
===TASK===-------DONE
make path following not count the initial spot
|
V
in the deepest pathfinding class (PathGrid?), make the intial spot not count

===TASK===------------DONE
When entity moves, it should move its pathing map
|
V
When the setPointPos function of an Entity is called, it should move the pathingMap of the Entity from its previous location
to the new location
|
V
Entity::setPointPos(QPointF pos){
    Map* map = map();
    if (map != nullptr){
        map->clearRegion(entitysregion);
        map->addRegion(entitiesregion)
    }
}

===TASK===-----DONE
Make it easier to add new effects
|
V
User should simply choose a sprite of the effect and where to spawn it. You should create it there, and then delete it.
|
V
Map should have the ability to create an effect at a certain area.
|
V
Map::createEffect(sprite, position)

===TASK===---------DONE
-make pathingMap reference semantics...(entities should have a pointer to a PathingMap)
    -this way, an entity can choose to not have a pathingmap (null)
    - no, a nullpathingmap (is one that does nothing no effect, is better, prevents null checking)
    
===TASK===
-add Bar Gui --------------------- DONE


===TASK===-----------DONE
-Map's width() and height() functions should simply delegate to the Map's PathingMap

===TASK===------DONE
-implement moving from map to map
-when the player gets to an edge, it should load the next map

===TASK===------DONE
-weathers should be a responsiblity of the Map, not game, move it there

===TASK===---------DONE
Refactor item pickup/dropping, equipping/unequipping, adding to inventory/removing from inventory

===TASK===--------------DONE
Make TerrainLayer a "layer" type of thing.
It should have a position, and you can set its position via, setPos

===TASK===
Ideas:
-implement weather effects (just the visuals) (rain, fog, snow, wind, cloudy, sunny (glares))----done
-implement better gui for inventory, equipment-slots -------------------------------------------------------done
-implement "outside map" fade --------------------------------------------------------------------------------done
-impelement ability to go from map to map ---------------------------------------------------------------done
-implement some sound effects-----------------------------------------------------------------------------done

===TASK===-----------DONE
Allow Gui class hierarchy to have parent/child relationship.
-When a parent Gui moves, so should all of its children
-When a parent Gui is removed from Game, so should all of its children
-When a parent Gui is deleted, so should all of its children

===TASK===
finish label - done
finish QuestViewer - done
|
v
Parts of quest viewer
-panel for entire background
-labels for the quest name ------ labels for quest status
-close button on very bottom

===TASK===------------DONE
Create a ScrollView Gui, that you can add other Gui's to and then scroll 
vertically to see different portions of the Gui's.
-seems like great practice for some math :)

===TASK===---------DONE
Make quests scrollable
|
V
QuestViewer, put all quest labels in a ScrollWindow

===TASKS===---------DONE
ScrollWindow, make width and height maxWidth, and maxHeight, respectively

===TASK===----DONE
Clean up Gui class hierarchy

===TASK===---------DONE
Make InventoryViewer use ScrollWindow

===TASK===----DONE
Come up with stuff to do
-finish quest viewer -- done
    - finish label -- done
    
===TASK===-------------DONE
Create entity controller that causes entity to go to another map when in edge.

===TASK===-------DON
When an entity enters a map, it should emit an event

===TASK===-----DONE
Create an entity controller that will switch game's current map to whatever map the controlled entity is in

===TASK===------DONE
For ShopGui, have a settable shopBehavior attribute that determines what happens when an item is attempted to be bought (i.e. subtract something from buyer?), this thing should return true if the buy is approved, false other wise.

=============================================================================
=============================================================================
=========================UNFINISHED TASKS====================================
=============================================================================
=============================================================================

===TASK===
Create youtube tutorial that creates a basic game
-player controlled entity (grabs cam and can go to other maps)
-creep entities
-creeps drop items (health, GoldItem, Weapons, NoTargetItem, TargetItem, etc...) 
-creeps respawn
-player keeps killing creeps, thus keeps getting new items
-there is a small "town" with some npcs (shop and quest giver)
-shop entity can sell you weapons in exchange for GoldItem
-quest giver has a few quests such as "kill 10 x", when completed, you get bonus gold


===TASK===
Entities will have a health attribute
-when health reaches 0, the entity destructs itself

===TASK===
Melee weapons should have a CollisionBehavior that determines what happens when it has collided with an entity (just like how Projectiles have a collision behavior)

===GREAT IDEA===
Put things in namespaces according to system, especially things that use strategy patter
i.e. behavior::collision::PushEntityOneBack
i.e. behavior::collision::PushEntityTwoBack
i.e. behavior::collision::PushBothEntitiesBack
i.e. behavior::entity::MoveInResponseToKeysRelativeToSelf
i.e. behavior::entity::MoveInResponseToKeysRelativeToScreen
i.e. behavior::entity::RotateToFaceMouse
i.e. behavior::entity::
*it doesn't have to be exact namespace above...just figure out a way to "catagorize" and sub catagorize your 

===TASK===
I have to eventually determine how entity controller clean up will happen.
-once the controlled entity is destroyed, the controller should automatically be destroyed? <---leaning towards this
-the controller should still live even when controlled entity is no longer alive
    - when the controlled entity dies, it should simply stop doing what its doing and wait till a new controlled entity is set
*solution i'v decided to go with
-state in the entity behavior documentation that entity behavior are automatically cleaned up when the entity dies
    - if a client is referencing an entity behavior, he should use a QPointer to point to it so that he'll know when its dead (no dangling pointer)
    *upon construction, EBs should listen to entitiy's destroyed event and in response should destroy themselves
    *problem solved
    
===TASK===
Refactor Map-Game-MapGrid relationship a little bit. Map should have reference to MapGrid, MapGrid should have reference to Game.
Game should have a MapGrid, MapGrid should have a bunch of Maps.
Game should have a currentMap. This currentMap must always be one of the maps in its MapGrid

===TASKS===
Go back through code and add const & to all parameters by default
-secondary but not as critical/easy, add const to functions that don't modify

===TASK===
Go back through code and add QPointer/smart pointers where necessary
-if a class needs to reference something it doesn't own (shared) that its track ("following" somehow), QPointer so we can tell when what we are tracking is dead
-if class creates (owns) something, consider using unique_ptr so memory is automatically cleaned up
-fuctions should still take by raw pointer unless they will participate in ownership somehow (i.e. either own it, or be one of the owners (shared))

===TASK===
Create an example game with game engine
-create an entty that is controlled via key/mouse ("player" entity)
-create some creep entities that will attack player entity when he enters their fov
-create an npc entity that gives quests
-creeps drop random items when dead (health potion included)
-quests are updated as completed (and reward given)

===TASK===
Write documentation for:
-entity (sprite, setters, getters, signals)
-entity controller system
-projectile system
-item/slot system
-weapon system
-gui system




===TASK===
Implement faster collision detection algorithm for Map
-divide and conquer
-entities should only check collision against a subset (those close, not ALL the entities) of the maps entities
-divide map into "sections"
-whenever an Entity moves, it should check which section its in (constant), remove itself from previous section and add to new
-when an entity needs to check which other entities its collliding with, it should only check the sub section
-this algorithm is O(n), n being the number of Entities per section
-classical divide and conquer strategy with space time tradeoff


===TASK===
-rain and snow (rain even more than snow) is confirmed to be too slow, try to make them faster
*if you don't believe old Abdullah and want to see for yourself that their slow (or you want to see if you've made them faster), simply try facing the mouse w/ and w/o them in the map and see how much faster it is without


===TASK===
Come up with a list of every thing that needs to be done in order for the first version of the game engine to be released
-in order to release, i need to have all the tools to be able to build an example game for my tutorials
    -what do i need to be able to build an example game for my tutorials
    -well what will my example game be like?
        -you will be a character
        -you will have an inventory
        -you will have items that can heal you
        -you will have npcs that can sell you items (and that you can sell to them)
        -you will have npcs that will give you quests
        -you will have "creeps" (attack non-creeps when they enter their sight/sound)
        -creeps can have random chance of dropping items
    *now I will do tasks one by one, to make creating the above game easy and informative
    
    ===SUB TASK===
    
                                                                                                
                                                            
===TASK===
- pick up item
- euip it
- use equipped item
- drop it
- move 
* causes crash, fix

===TASK===
-join dynamic entities and entities back into one class -- done
-make entity default sprite say "default sprite" instead of being blank
-create an entity controller that chases nearby entities -- done
-create an entity controller that will have entity body thrust nearby eneities

===TASK===
Go back through API doc of each class and include an example usage:
                                                            
                                                            
                                                            
                                                            





