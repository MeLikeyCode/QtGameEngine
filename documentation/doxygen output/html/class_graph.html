<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QtGameEngine: Graph Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">QtGameEngine
   &#160;<span id="projectnumber">very early alpha</span>
   </div>
   <div id="projectbrief">Game engine for the Qt framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_graph-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Graph Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents a <a class="el" href="class_graph.html" title="Represents a Graph. ">Graph</a>.  
 <a href="class_graph.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_graph_8h_source.html">Graph.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae4c72b8ac4d693c49800a4c7e273654f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ae4c72b8ac4d693c49800a4c7e273654f">Graph</a> ()</td></tr>
<tr class="memdesc:ae4c72b8ac4d693c49800a4c7e273654f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor, constructs a <a class="el" href="class_graph.html" title="Represents a Graph. ">Graph</a> with no Nodes or Edges (empty <a class="el" href="class_graph.html" title="Represents a Graph. ">Graph</a>).  <a href="#ae4c72b8ac4d693c49800a4c7e273654f">More...</a><br /></td></tr>
<tr class="separator:ae4c72b8ac4d693c49800a4c7e273654f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c328ab0be44bf282d97213e061f0ff"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a45c328ab0be44bf282d97213e061f0ff">Graph</a> (const std::unordered_set&lt; <a class="el" href="class_node.html">Node</a> &gt; &amp;<a class="el" href="class_graph.html#a5f1639c379fb0b3d94c7129e248b9605">nodes</a>, const std::unordered_set&lt; <a class="el" href="class_edge.html">Edge</a> &gt; &amp;<a class="el" href="class_graph.html#ac33e745d64105a7811f2d4d6328c53c3">edges</a>)</td></tr>
<tr class="memdesc:a45c328ab0be44bf282d97213e061f0ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="class_graph.html" title="Represents a Graph. ">Graph</a> from the given set of Nodes and Edges.  <a href="#a45c328ab0be44bf282d97213e061f0ff">More...</a><br /></td></tr>
<tr class="separator:a45c328ab0be44bf282d97213e061f0ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1639c379fb0b3d94c7129e248b9605"><td class="memItemLeft" align="right" valign="top">std::unordered_set&lt; <a class="el" href="class_node.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a5f1639c379fb0b3d94c7129e248b9605">nodes</a> () const</td></tr>
<tr class="memdesc:a5f1639c379fb0b3d94c7129e248b9605"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a set of all the Nodes in the <a class="el" href="class_graph.html" title="Represents a Graph. ">Graph</a>.  <a href="#a5f1639c379fb0b3d94c7129e248b9605">More...</a><br /></td></tr>
<tr class="separator:a5f1639c379fb0b3d94c7129e248b9605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac33e745d64105a7811f2d4d6328c53c3"><td class="memItemLeft" align="right" valign="top">std::unordered_set&lt; <a class="el" href="class_edge.html">Edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ac33e745d64105a7811f2d4d6328c53c3">edges</a> () const</td></tr>
<tr class="memdesc:ac33e745d64105a7811f2d4d6328c53c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a set of all the Edges in the <a class="el" href="class_graph.html" title="Represents a Graph. ">Graph</a>.  <a href="#ac33e745d64105a7811f2d4d6328c53c3">More...</a><br /></td></tr>
<tr class="separator:ac33e745d64105a7811f2d4d6328c53c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9172dbcac073750e55675af67b6d060e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_edge.html">Edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a9172dbcac073750e55675af67b6d060e">outgoingEdges</a> (const <a class="el" href="class_node.html">Node</a> &amp;from) const</td></tr>
<tr class="memdesc:a9172dbcac073750e55675af67b6d060e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of all the outgoing Edges from the specified <a class="el" href="class_node.html" title="Represents a node. ">Node</a>.  <a href="#a9172dbcac073750e55675af67b6d060e">More...</a><br /></td></tr>
<tr class="separator:a9172dbcac073750e55675af67b6d060e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b599c4368559749cb8ba37839c4a0c3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_edge.html">Edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a3b599c4368559749cb8ba37839c4a0c3">incomingEdges</a> (const <a class="el" href="class_node.html">Node</a> &amp;to) const</td></tr>
<tr class="memdesc:a3b599c4368559749cb8ba37839c4a0c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of all the incoming Edges to the specified <a class="el" href="class_node.html" title="Represents a node. ">Node</a>.  <a href="#a3b599c4368559749cb8ba37839c4a0c3">More...</a><br /></td></tr>
<tr class="separator:a3b599c4368559749cb8ba37839c4a0c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d9acc352704827844d312942b8552c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_node.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ad9d9acc352704827844d312942b8552c">outgoingNodes</a> (const <a class="el" href="class_node.html">Node</a> &amp;from) const</td></tr>
<tr class="memdesc:ad9d9acc352704827844d312942b8552c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of all the <em>adjacent</em> Nodes that this <a class="el" href="class_node.html" title="Represents a node. ">Node</a> can go to.  <a href="#ad9d9acc352704827844d312942b8552c">More...</a><br /></td></tr>
<tr class="separator:ad9d9acc352704827844d312942b8552c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20e8b2e197b9dbcc1202ba414e99240d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_node.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a20e8b2e197b9dbcc1202ba414e99240d">incomingNodes</a> (const <a class="el" href="class_node.html">Node</a> &amp;to) const</td></tr>
<tr class="memdesc:a20e8b2e197b9dbcc1202ba414e99240d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of all the <em>adjacent</em> Nodes that can come to this <a class="el" href="class_node.html" title="Represents a node. ">Node</a>.  <a href="#a20e8b2e197b9dbcc1202ba414e99240d">More...</a><br /></td></tr>
<tr class="separator:a20e8b2e197b9dbcc1202ba414e99240d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3e959a7eef214ef51d2c1c7f51f8052"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ad3e959a7eef214ef51d2c1c7f51f8052">contains</a> (const <a class="el" href="class_node.html">Node</a> &amp;node) const</td></tr>
<tr class="memdesc:ad3e959a7eef214ef51d2c1c7f51f8052"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the <a class="el" href="class_graph.html" title="Represents a Graph. ">Graph</a> contains the specified <a class="el" href="class_node.html" title="Represents a node. ">Node</a>.  <a href="#ad3e959a7eef214ef51d2c1c7f51f8052">More...</a><br /></td></tr>
<tr class="separator:ad3e959a7eef214ef51d2c1c7f51f8052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3cc6432d9cc0d2eea23a82ff44af8c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ae3cc6432d9cc0d2eea23a82ff44af8c1">contains</a> (const <a class="el" href="class_edge.html">Edge</a> &amp;edge) const</td></tr>
<tr class="memdesc:ae3cc6432d9cc0d2eea23a82ff44af8c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the <a class="el" href="class_graph.html" title="Represents a Graph. ">Graph</a> contains the specified <a class="el" href="class_edge.html" title="Represents an edge between two Nodes. ">Edge</a>.  <a href="#ae3cc6432d9cc0d2eea23a82ff44af8c1">More...</a><br /></td></tr>
<tr class="separator:ae3cc6432d9cc0d2eea23a82ff44af8c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01292a8c799a1173b8a244e8ed30dba5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_node.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a01292a8c799a1173b8a244e8ed30dba5">shortestPath</a> (const <a class="el" href="class_node.html">Node</a> &amp;from, const <a class="el" href="class_node.html">Node</a> &amp;to) const</td></tr>
<tr class="memdesc:a01292a8c799a1173b8a244e8ed30dba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of Nodes that represent the shortest path between the specified Nodes.  <a href="#a01292a8c799a1173b8a244e8ed30dba5">More...</a><br /></td></tr>
<tr class="separator:a01292a8c799a1173b8a244e8ed30dba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7df7eaa465581f236bde28d047e4ac1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tree.html">Tree</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a7df7eaa465581f236bde28d047e4ac1c">spt</a> (const <a class="el" href="class_node.html">Node</a> &amp;source) const</td></tr>
<tr class="memdesc:a7df7eaa465581f236bde28d047e4ac1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a shortest path <a class="el" href="class_tree.html" title="Represents a tree. ">Tree</a> rooted at the specified ("source") <a class="el" href="class_node.html" title="Represents a node. ">Node</a>.  <a href="#a7df7eaa465581f236bde28d047e4ac1c">More...</a><br /></td></tr>
<tr class="separator:a7df7eaa465581f236bde28d047e4ac1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14152fb5f4ef5def4967484245747ffd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a14152fb5f4ef5def4967484245747ffd">addNode</a> (const <a class="el" href="class_node.html">Node</a> &amp;node)</td></tr>
<tr class="memdesc:a14152fb5f4ef5def4967484245747ffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the specified <a class="el" href="class_node.html" title="Represents a node. ">Node</a> to the <a class="el" href="class_graph.html" title="Represents a Graph. ">Graph</a>.  <a href="#a14152fb5f4ef5def4967484245747ffd">More...</a><br /></td></tr>
<tr class="separator:a14152fb5f4ef5def4967484245747ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf8d2317f5dac0d8fb3b015620009032"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#aaf8d2317f5dac0d8fb3b015620009032">addEdge</a> (const <a class="el" href="class_node.html">Node</a> &amp;from, const <a class="el" href="class_node.html">Node</a> &amp;to, int weight)</td></tr>
<tr class="memdesc:aaf8d2317f5dac0d8fb3b015620009032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an <a class="el" href="class_edge.html" title="Represents an edge between two Nodes. ">Edge</a> between the specified Nodes.  <a href="#aaf8d2317f5dac0d8fb3b015620009032">More...</a><br /></td></tr>
<tr class="separator:aaf8d2317f5dac0d8fb3b015620009032"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents a <a class="el" href="class_graph.html" title="Represents a Graph. ">Graph</a>. </p>
<dl class="section author"><dt>Author</dt><dd>Abdullah Aghazadah </dd></dl>
<dl class="section date"><dt>Date</dt><dd>4-24-15</dd></dl>
<p>A <a class="el" href="class_graph.html" title="Represents a Graph. ">Graph</a> is a set of Nodes and Edges. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae4c72b8ac4d693c49800a4c7e273654f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4c72b8ac4d693c49800a4c7e273654f">&#9670;&nbsp;</a></span>Graph() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Graph::Graph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor, constructs a <a class="el" href="class_graph.html" title="Represents a Graph. ">Graph</a> with no Nodes or Edges (empty <a class="el" href="class_graph.html" title="Represents a Graph. ">Graph</a>). </p>

</div>
</div>
<a id="a45c328ab0be44bf282d97213e061f0ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45c328ab0be44bf282d97213e061f0ff">&#9670;&nbsp;</a></span>Graph() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Graph::Graph </td>
          <td>(</td>
          <td class="paramtype">const std::unordered_set&lt; <a class="el" href="class_node.html">Node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_set&lt; <a class="el" href="class_edge.html">Edge</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="class_graph.html" title="Represents a Graph. ">Graph</a> from the given set of Nodes and Edges. </p>
<p>Please ensure that all of the Nodes of the Edges are actually Nodes in the set of Nodes. In other words, please make sure that the set of Nodes and Edges being passed in actually represent a graph. This constructor does not do any checking. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aaf8d2317f5dac0d8fb3b015620009032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf8d2317f5dac0d8fb3b015620009032">&#9670;&nbsp;</a></span>addEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::addEdge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an <a class="el" href="class_edge.html" title="Represents an edge between two Nodes. ">Edge</a> between the specified Nodes. </p>
<p>The <a class="el" href="class_edge.html" title="Represents an edge between two Nodes. ">Edge</a> will not be added if an equivalent one is already added in the <a class="el" href="class_graph.html" title="Represents a Graph. ">Graph</a>. </p>

</div>
</div>
<a id="a14152fb5f4ef5def4967484245747ffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14152fb5f4ef5def4967484245747ffd">&#9670;&nbsp;</a></span>addNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::addNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the specified <a class="el" href="class_node.html" title="Represents a node. ">Node</a> to the <a class="el" href="class_graph.html" title="Represents a Graph. ">Graph</a>. </p>
<p>The <a class="el" href="class_node.html" title="Represents a node. ">Node</a> will not be added if an equivalent one is already in the <a class="el" href="class_graph.html" title="Represents a Graph. ">Graph</a>. </p>

</div>
</div>
<a id="ad3e959a7eef214ef51d2c1c7f51f8052"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3e959a7eef214ef51d2c1c7f51f8052">&#9670;&nbsp;</a></span>contains() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the <a class="el" href="class_graph.html" title="Represents a Graph. ">Graph</a> contains the specified <a class="el" href="class_node.html" title="Represents a node. ">Node</a>. </p>

</div>
</div>
<a id="ae3cc6432d9cc0d2eea23a82ff44af8c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3cc6432d9cc0d2eea23a82ff44af8c1">&#9670;&nbsp;</a></span>contains() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_edge.html">Edge</a> &amp;&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the <a class="el" href="class_graph.html" title="Represents a Graph. ">Graph</a> contains the specified <a class="el" href="class_edge.html" title="Represents an edge between two Nodes. ">Edge</a>. </p>

</div>
</div>
<a id="ac33e745d64105a7811f2d4d6328c53c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac33e745d64105a7811f2d4d6328c53c3">&#9670;&nbsp;</a></span>edges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_set&lt; <a class="el" href="class_edge.html">Edge</a> &gt; Graph::edges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a set of all the Edges in the <a class="el" href="class_graph.html" title="Represents a Graph. ">Graph</a>. </p>

</div>
</div>
<a id="a3b599c4368559749cb8ba37839c4a0c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b599c4368559749cb8ba37839c4a0c3">&#9670;&nbsp;</a></span>incomingEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="class_edge.html">Edge</a> &gt; Graph::incomingEdges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of all the incoming Edges to the specified <a class="el" href="class_node.html" title="Represents a node. ">Node</a>. </p>
<p>Incoming edges are those that <em>end</em> at the specified <a class="el" href="class_node.html" title="Represents a node. ">Node</a> (can start on any other <a class="el" href="class_node.html" title="Represents a node. ">Node</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to</td><td>The <a class="el" href="class_node.html" title="Represents a node. ">Node</a> to get all the incoming Edges of. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a20e8b2e197b9dbcc1202ba414e99240d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20e8b2e197b9dbcc1202ba414e99240d">&#9670;&nbsp;</a></span>incomingNodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="class_node.html">Node</a> &gt; Graph::incomingNodes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of all the <em>adjacent</em> Nodes that can come to this <a class="el" href="class_node.html" title="Represents a node. ">Node</a>. </p>
<p>I.e all the Nodes that have an incoming <a class="el" href="class_edge.html" title="Represents an edge between two Nodes. ">Edge</a> to this <a class="el" href="class_node.html" title="Represents a node. ">Node</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to</td><td>The <a class="el" href="class_node.html" title="Represents a node. ">Node</a> to get all the <em>adjacent</em> incoming Nodes of. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f1639c379fb0b3d94c7129e248b9605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f1639c379fb0b3d94c7129e248b9605">&#9670;&nbsp;</a></span>nodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_set&lt; <a class="el" href="class_node.html">Node</a> &gt; Graph::nodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a set of all the Nodes in the <a class="el" href="class_graph.html" title="Represents a Graph. ">Graph</a>. </p>

</div>
</div>
<a id="a9172dbcac073750e55675af67b6d060e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9172dbcac073750e55675af67b6d060e">&#9670;&nbsp;</a></span>outgoingEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="class_edge.html">Edge</a> &gt; Graph::outgoingEdges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of all the outgoing Edges from the specified <a class="el" href="class_node.html" title="Represents a node. ">Node</a>. </p>
<p>Outgoing edges are those that <em>start</em> at the specified <a class="el" href="class_node.html" title="Represents a node. ">Node</a> (and end on any other <a class="el" href="class_node.html" title="Represents a node. ">Node</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>The <a class="el" href="class_node.html" title="Represents a node. ">Node</a> to get all the outoing Edges of. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad9d9acc352704827844d312942b8552c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9d9acc352704827844d312942b8552c">&#9670;&nbsp;</a></span>outgoingNodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="class_node.html">Node</a> &gt; Graph::outgoingNodes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of all the <em>adjacent</em> Nodes that this <a class="el" href="class_node.html" title="Represents a node. ">Node</a> can go to. </p>
<p>I.e. all the Nodes that this <a class="el" href="class_node.html" title="Represents a node. ">Node</a> has an outoing <a class="el" href="class_edge.html" title="Represents an edge between two Nodes. ">Edge</a> to.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>The <a class="el" href="class_node.html" title="Represents a node. ">Node</a> to get the adjacent outgoing Nodes of. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a01292a8c799a1173b8a244e8ed30dba5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01292a8c799a1173b8a244e8ed30dba5">&#9670;&nbsp;</a></span>shortestPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="class_node.html">Node</a> &gt; Graph::shortestPath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of Nodes that represent the shortest path between the specified Nodes. </p>
<p>Uses A* pathfinding algorithm. </p>

</div>
</div>
<a id="a7df7eaa465581f236bde28d047e4ac1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7df7eaa465581f236bde28d047e4ac1c">&#9670;&nbsp;</a></span>spt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tree.html">Tree</a> Graph::spt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a shortest path <a class="el" href="class_tree.html" title="Represents a tree. ">Tree</a> rooted at the specified ("source") <a class="el" href="class_node.html" title="Represents a node. ">Node</a>. </p>
<p>Uses dijkstras algorithm therefore it is O(mlog(n)). </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/GitHubProjects/QtGameEngine/<a class="el" href="_graph_8h_source.html">Graph.h</a></li>
<li>C:/GitHubProjects/QtGameEngine/<a class="el" href="_graph_8cpp.html">Graph.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
