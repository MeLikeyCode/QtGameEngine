===TASKS===-----------------DONE
Allow an Entity to quickly swap its movment behavior
-an Entity can be AI or Player controlled
-if it is player controlled, its movePlayerControlled() function will be executed
    -this function will move the Entity 1 step closer in response to the current keys being pressed
-if it is AI controlled, TODO will figure this out later
-encapsulate movement behaviors in classes
-an entity has a MovementBehavior


===TASK===----------------DONE
An entity should have two move functions
    -movePlayerControlled() // fires when entity is player controlled - moves in response to input
    -moveAIControlled() // fiers when entity is AI controlled - moves in response to its own thinking
If the entity isPlayerControlled(), its movePlayerControlled() function should executed, other wise its moveAIControlled()

===TASK===---------------DONE
Test to see if you can dynamically set/unset an entity to be controlled by player/ai
-how:connect to right click of mouse in game

===TASK===------------DONE
An entity that is player controlled should be able to dynamically swap the way it moves (up/down relative to facing, or relative to screen? etc...)
Right now:
    -if an entity isPlayerControlled(), its moveStepPlayerControlled() function will periodically executed
    -this function has the code that will move the enity in response to keyboard/mouse events
    -i need to take this code out and put it in a class that provides a moveStep() function
        -this class points to an entity
        -calling its moveStep() will operate on that entity
     -i can make anotehr class that also provides a moveStep() function but moves in a diff way (still has an entity ptr)
SO:
    -need interface PlayerControlledMoveBehavior w functions:
        -setEntity()
        -moveStep() // when called moves the entity according to logic of this MoveBehavior
     -need two classes that implement this interface
        -one that moves in the way currently
        -another that moves in relative to screen coordinates
        
===TASK===--------------DONE
Create a new PlayerControlledMoveBehavior called MoveRelativeToScreen that moves the entity relative to 
the screen.

===TASK===--------------DONE
A Weapon should not have all the qualities of an advanced entity such as path finding and such. You should not be able even call this type of functionality on a Weapon. Therefore I must extract the base functionality and put it in an Entity class. Advanced entities can subclass this (such as a Character entity, with pathfinding abilities). Weapon class can also subclass this and have its own abilities (such as attack).
Thinking stack:
-a MeleeWeapon should not have all the behaviors of an Entity (such as moveTo())
-then it should not inherit Entity, why is it inheriting the entity?
-to be able to use the Entity parent/child system
-entity parent/child system should be implemented at the "Entity" level (Character and Weapon should inherit)
SO:
    -need a bare Entity class where parent/child system is implemented ----- done
        -when parent moves, children move
        -when parent rotates, children rotates
        -when parent dies, children are killed
    -need a 
SO:
    -need an need a dynamic entity that can move on its own or in response to user control

    
===TASK===--------------DONE
Improve spear system
-should only do damage if it is hitting while going forward - done
-should go back as soon as hitting something - done
-should have a length variable - done
-should have a width variable - done
-should have an attachment point variable - done
-should have a thrust speed and thrust distance variable - done

===TASK===--------------DONE
-remove attackSwing(), attackThrust(), etc...from MeleeWeapon class and just give it a attack() method - done
-the attack() method should smartly determine whether it wants to swing, thrust, etc...

===TASK===--------------DONE
-download/polish/import axe picture - done
create basic Axe class (skeletal framework, copy spear and then edit accordingly)

===TASK=== --------------DONE
Plan a swinging weapon (Axe class)
-should have a set swingClockWise(), set counterClockWise()
-Axe::attack()
    -should attack by swinging
    -should check for collision at "point"
    -each step, should move in the direction of clock or counter clock wise

===TASK===
Fix Axe swing animation --------DONE

===TASK===----------DONE
Move function documentation from the .cpp files to the .h files.
I changed my mind. Since I will be releasing the source of this framework, the user can easily browse through function declarations and "follow" the ones he/she would like to see the documentation for.Additionally, putting the docuementation 
in the source file is advantageous because the public api docuementation is close to an additional source of docuementation - the code itself (as well as any comments around it).

===TASK===----------DONE
I want a MusicPlayer class. Internally it has a QMediaPlayer. It can take a list of songs and play them in order or in shuffel.
It can loop a song a certain number of times or infinitely.

===TASK===-------------DONE
Move common behavior of Axe and Spear into a base class.
Common behavior:
setTip()
resetTip()
tip()
setLength()
setWidth()
width()

===TASK===---------------DONE
Give DynamicEntitys an Inventory of Items. A DynamicEntity can equip() certain Items (EquipableItems) in its Inventory. When an Item is equipped, that Item remembers who it is equiped by, and it will do its effect to the benefit of that DynamicEntity. Furthermore, Items know which Inventory they are a part of, and an Inventory knows which DynamicEntity it is a part of, therefore essentially each Item will know whos Inventory they are a part of, thus they will give their effect to that DynamicEntity.

need the following classes:
Inventory
-entity()
Item
-inventory()
-charges()
-use()
-equip() // some items need to be told where to equip to (leftHand, rightHand, any namedPoint)

===TASK===----------------DONE
Implement equipment slot system:
-an Entity has a bunch of equipment slots
-when an EquipableItem is equiped at a certain slot, that slot gets filled (trying to equip to it again won't work)
-Entity needs to maintain a set of "slots"
-The Entity can use() the item at a certain slot (if an Item has be equipped at that slot) 


===TASK===-------------DONE
make a range weapon
|
V
- create a RangedWeapon class with an attack(point) virtual function
- create a RangedWeaponSlot class whos canEquip(Item) function returns true only for RangedWeaponSlot
- create a Bow class (concrete RangedWeapon) that shoots an arrow at the specified point
- create a Projectile base class
    -a projectile moves to a target
- create a StraightProjectile class that moves in a straight line till it reaches its target
- create a ZigzagProjectile that will zigzag to its target point
|
V
- create a Projectile class that
    - has a target point (QPointF)
    - has a set of entities that it will not damage
    - has a virtual step() function
    - has an int describing how often the step() function should be called
    - has a start() function that will connect timer and start calling step()
    
- create a StraightProjectile
    -inherits from Projectile
    - has a settable sprite
    - has a settable damage
    - step() - every step will move closer to point (which must be passed in constructr)
    
===TASK===----------DONE
Move ""setting the facing angle"" responsibility of a StraightProjectile to the StraightProjectile class itself

===TASK===-----------DONE
-entities should have a field of view  modeled as a triangle
-entities should be able to tell you the other entities in its field of view

===TASK===------------DONE
Test field of view for Entities
-one click should place entity
-the other click should tell you the number of things in view
-draw sides just to check
*debug: it doesn't work, find out why DynamicEntity::entitiesInFieldOfView() doesn't work?

===TASK===-----------DONE
Make Projectile system use strateg pattern rathern than inheretence
-a Projectile should have a ProjectileMoveBehavior that has a onStep() which defines how the projectile moves every step.
-a Projectile should have a ProjectileCollisionBehavior that has a onCollide(std::unordered_set<Entity> entities) function that determines the behavior of the projectile in response to colliding
-a Projectile should have a ProjectileRangeReachedBehavior that has a onRangeReached() that defines how the projectile responds to reaching its range.

-implement a ProjectileMoveBehaviorStraight
-implement a ProjectileCollisionBehaviorDamage
-implement a ProjectileRangeReachedBehaviorDestroy
-implment a ProjectileMoveBehaviorHoming
    -this algorithm is already defined in one of my classes
    -copy it from there 
    
===TASK===------------DONE
Create an Enemy that will continueously check his field of view, if someone not in his group enters, he will move to that 
position.
|
V
Enemy will have a function that will periodically check what is in his field of view, it will travers through them and if
the group doesnt match the Enemies, then it will move to the location of the entity and disconnect for a little while

===TASK===------------DONE
start: 830 pm
end:
When Enemy is moving to attack an entity, when it gets close enough (range of his default weapon), he will use his weapon.

subtasks
- all Weapons should have a castRange -- done
- MeleeWeapon and RangedWeapon should inherti from Weapon, which has an attack(point) abstract method -- done
    -MeleeWeapon will ignore the point
    -Ranged will use it
 -Weapon Slot that can house any Weapon (Melee or Ranged), will simplly call the attack of the weapon -- done
-move inventory/item/equipment responsibility from Entity to DynamicEntity -- done
-When a DynamicEntity equips a Weapon, if its the first, it should be the defaultWeapon.
-when enemy is moving towards its enemy, it should check if weapon is in range, if so, it should swing/attach it

===TASK===------done
When an Entity is added to a map
-all child entities should be added to map (if they are already not in the map, if in other map, should be removed from there and then added to new map)

===TASK=== --- done
-test if enemy works with other weapons
-spear? __ no
-axe? __ no

-spear and axe kill Enemy when it strikes

debugging
-the spear does not have a map to return via map() function
-when Enemy adds the spear to its inv in its constructor, the enemy has no map therefore the spear has no map either/
    -then why it shows up?
    
-when the enemy is added to map, all of its children are added also
-but the spear is not a child of the enemy

-Entity::setParentEntity() works imporperly
    -
    
===TASK=== ---- done
Entity::children() returns a reference to an internal collection
-have a addChild(), removeChild() member function
-search for all code that uses children(), replace it w one of above functions
-have children() return a read only list (copy)

===TASK===
Pathfinding algorithm should take place in another thread and call back when done (move like a dumbass till then)

===TASK===---------done
-entities move backward every once in a while
-this is probably because when the path is finally calculated in the other thread, the object has already moved forward,
so then when he gets the results, he starts going to the first point (which was at a previous place)

===TASK===-------done
Clean up/refactor movement system and async path finder
-see if movement is fast enough now - done (ok for now, can handle about 5-6 entiteis at same time)
-see if adding rocks in path still succesfully recalculates - done
-make sure after asyncshortestpathfinder finds path, it cleans up the worker and thread - done

===TASK===-----------DONE
GREAT IDEA
-DynamicEntitys should not auto recalculate path upon EACH move
-instead they should recalculate path only when "stuck"
-make it so that entities cannot go forward unless there is freedom in that cell (just like player controlled move does)
-when an entity has been "stuck" for x amount of time, it should recalculate path to its target!

===TASK===-----DONE
When a path is calculated from nodeN to the same nodeN, it should return a vector of 0, instead of just crashing.

===TASK===---------DONE
Implement "group" system
-each AI entity should have a groupId
-each AI entity should have a list of friend groups and  a list of enemy groups
-when an enemy group is in view, it should set it as its target
-when the enemy is out of view, it should stop pursueing (target=nullptr)
-when the pursuent (entity being purused) is dead, should stop pursueing (need to know when target entity dies)

todo:
-add groupID_ field to Entity

===TASK===--------------DONE
Every entity needs to have health.
Every entity needs to know what it can be damaged by and what it can't be damage by.
-entity can be damaged by only the following {}
-entity can be damaged by anything but the following {}
-anytime an entity attempts to deal damage to another entity (i.e. projectile to enemy), it should do so through Entity::attemptDamageTo(Entity* target)
*done, but need to make weapon use damage() rather than just deleteing what it touches <-- LEFT OVER

===TASK===---------DONE
Camera/move system
Game should be able to move the camera around the map
|
V
Game represents the game. Game has a Map. Game visualize a certain portion of the Map.
|
V
Game provides a function for setting the center of the camera at some point on the map
Game provides a function for moving the camera by a vector
Game provides a function for moving the camera up/down/left/right by a certain amount (specialization of previous problem)
|
V
Game::setCameraPos(QPoinF to); // sets the position of the camera (center the camera) to the specified point on the Map
Game::moveCamera(QVector2D byVector);
Game::moveCamUp(double by); // also down, left, right

===TASK===-------------DONE
-make terrain/map huge
-spawn player
-have camera follow player
    - in DynamiEntity's movement mode, if camerafolllow mode, move to player - done

===TASK===-------------done
Pathfinding needs to happen in another thread

===TASK===------------DONE
Old pathfinding is a bit too slow for all cases (useful in some - so still keep it around). Need to make an alternative.
|
V
When entity e is told to move to position p
-draw line from e to p, if there are no obsticles -> move straight
-if there are obsticles then calculate path

moveTo(Point p){
    // set target point
    
    // draw line, if no obsticles, take step towards point
    stepTowardsTarget()
    
    // if obsticles, pathfind (in current thread)
}

// yet another alternative Ai movement
*used A*, much faster

===TASK===----------DONE
The same entity can be in multiple lists, when its deleted from one list, its dangled in the other.
|
V
Every so often projectileA gets list of colliding units, goes through and deletes, some
Every so often projectileB gets list of colliding units (may have same stuff as list a)
Since projectileA deltes some, now projectileB has dangling pointers
|
V
Solution:
QPointer

===TASK===-------------DONE
Projectile system is a bit messed up. Projectiles move back and forth.

===TASK====---------DONE
Refactor
-look at one class at a time
-what happens if it dies?
-what happens if one of its pointers_ dies? does he clean dangling pointers?

-any excess "includes"? (forward declare instead)

done:
-AsyncShortestPathFinder
-Axe
-Bow
-CountExpiringTimer
-DynamicEntity
-Edge

// this was another task, merged it with above task
Go back and handle deleting/removing/clean up of all objects/classes
-when one enemy destroys another enemy, crashes
    -b/c the killer enemy still has a dangling reference to the killed enemy

solution: QObjects have a destroyed() signal that is emitted right before the object gets deleted. You should listen 
for this signal and respond appropriately to avoid dangling references.
-enemies should do this, when target_ is destroyed(), they should stop pursueing

===TASK===----------DONE
Research on C++ move ctor - done
Research why new should be decoupled from business logic (besides making classes testable)
Research if using static data/functions is something you should (almost) always avoid?

===TASK===---------DONE
I have
-entities that can see, move, have enemies, projectiles, pathfinding, sprites, camera movement, cam following, items

I feel like I need to improve the item system...let me review the inventory, item, equipment system

===TASK===------------DONE
complete item/inventory system
make a couple of examples items, place them on the ground, pick them up in your inventory, use them, drop them etc
|
V
design/plan gui for inventory
|
V
design/plan general gui system
|
V

====TASK===-----------DONE
compete item/inventory system
|
V
create an item that upon use will shoot out a fan of spears
|
V
create a NoTargetItem that on its use() will spawn a bunch of projectiles that go out in all directions

===TASK===------------DONE
Item system needs to be refactored a little bit
-specifically, the item drop/pick up, depends on making the item visible/invisible...this is a bad idea becaus, even when
invisible, entities can be damaged!

item system is comprised of the following classes:
Item abstract class and its concrete subclasses
Slot abstract class and concrete subclasses that can equip/unequip various item types
DynamicEntity which can have a bunch of Slots
Inventory which is a collection of Items (that can be added/removed from the inventory)
InventoryCell which visually represents an Item in an inventory and allows a) dropping it from inv and b) using it from inv
InventoryViewer which is a collection of InventoryCells. Inventory cells can be added/removed from it and it will update display.

===TASK===-------DONE
Implement a PointTargetItem and EntityTargetItem

PointTargetItem: -- DONE
Teleport
-teleports the owner to the specified location

EntityTargetItem:----DONE
push back
-pushes target entity back from owner

===TASK=== --------DONE
-implement mouse modes
-finish implementing PointTargetItem and EntityTargetItem

===TASK===------DONE
create a few concrete projectile classes that instantiate the correct respective behaviors
-create spearprojectile - done
-create a PlayerControlledMoveBehaviorSine(amplitude, period, range)

===TASK===-------DONE
Refactor recently added code (Item system in general)

    -setSize(int w, int h) should go in Entity (simply set the size of current frame and ALL pixmaps of all animations to size)

    
===TASK===-------DONE
make path following not count the initial spot
|
V
in the deepest pathfinding class (PathGrid?), make the intial spot not count

===TASK===------------DONE
When entity moves, it should move its pathing map
|
V
When the setPointPos function of an Entity is called, it should move the pathingMap of the Entity from its previous location
to the new location
|
V
Entity::setPointPos(QPointF pos){
    Map* map = map();
    if (map != nullptr){
        map->clearRegion(entitysregion);
        map->addRegion(entitiesregion)
    }
}

===TASK===-----DONE
Make it easier to add new effects
|
V
User should simply choose a sprite of the effect and where to spawn it. You should create it there, and then delete it.
|
V
Map should have the ability to create an effect at a certain area.
|
V
Map::createEffect(sprite, position)

===TASK===---------DONE
-make pathingMap reference semantics...(entities should have a pointer to a PathingMap)
    -this way, an entity can choose to not have a pathingmap (null)
    - no, a nullpathingmap (is one that does nothing no effect, is better, prevents null checking)
    
===TASK===
-add Bar Gui --------------------- DONE


===TASK===-----------DONE
-Map's width() and height() functions should simply delegate to the Map's PathingMap

===TASK===------DONE
-implement moving from map to map
-when the player gets to an edge, it should load the next map

===TASK===------DONE
-weathers should be a responsiblity of the Map, not game, move it there

===TASK===---------DONE
Refactor item pickup/dropping, equipping/unequipping, adding to inventory/removing from inventory

===TASK===--------------DONE
Make TerrainLayer a "layer" type of thing.
It should have a position, and you can set its position via, setPos

===TASK===
Ideas:
-implement weather effects (just the visuals) (rain, fog, snow, wind, cloudy, sunny (glares))----done
-implement better gui for inventory, equipment-slots -------------------------------------------------------done
-implement "outside map" fade --------------------------------------------------------------------------------done
-impelement ability to go from map to map ---------------------------------------------------------------done
-implement some sound effects-----------------------------------------------------------------------------done

===TASK===-----------DONE
Allow Gui class hierarchy to have parent/child relationship.
-When a parent Gui moves, so should all of its children
-When a parent Gui is removed from Game, so should all of its children
-When a parent Gui is deleted, so should all of its children

===TASK===
finish label - done
finish QuestViewer - done
|
v
Parts of quest viewer
-panel for entire background
-labels for the quest name ------ labels for quest status
-close button on very bottom

===TASK===------------DONE
Create a ScrollView Gui, that you can add other Gui's to and then scroll 
vertically to see different portions of the Gui's.
-seems like great practice for some math :)

===TASK===---------DONE
Make quests scrollable
|
V
QuestViewer, put all quest labels in a ScrollWindow

===TASKS===---------DONE
ScrollWindow, make width and height maxWidth, and maxHeight, respectively

===TASK===----DONE
Clean up Gui class hierarchy

===TASK===---------DONE
Make InventoryViewer use ScrollWindow

===TASK===----DONE
Come up with stuff to do
-finish quest viewer -- done
    - finish label -- done
    
===TASK===-------------DONE
Create entity controller that causes entity to go to another map when in edge.

===TASK===-------DON
When an entity enters a map, it should emit an event

===TASK===-----DONE
Create an entity controller that will switch game's current map to whatever map the controlled entity is in

===TASK===------DONE
For ShopGui, have a settable shopBehavior attribute that determines what happens when an item is attempted to be bought (i.e. subtract something from buyer?), this thing should return true if the buy is approved, false other wise.

===TASK===-------DONE
Entities will have a health attribute
-when health reaches 0, the entity destructs itself

===TASK===-----DONE
Melee weapons should have a CollisionBehavior that determines what happens when it has collided with an entity (just like how Projectiles have a collision behavior)

===TASK===-----DONE
Come up with a list of every thing that needs to be done in order for the first version of the game engine to be released
-in order to release, i need to have all the tools to be able to build an example game for my tutorials
    -what do i need to be able to build an example game for my tutorials
    -well what will my example game be like?
        -you will be a character
        -you will have an inventory
        -you will have items that can heal you
        -you will have npcs that can sell you items (and that you can sell to them)
        -you will have npcs that will give you quests
        -you will have "creeps" (attack non-creeps when they enter their sight/sound)
        -creeps can have random chance of dropping items
    *now I will do tasks one by one, to make creating the above game easy and informative
    
    ===SUB TASK===

===TASK===----DONE
Go back through one file at a time and
-check to make sure class documentation is *clear* and informative
-method arguments are taken by const ref whenever possible
-constructors use field initializer list whenever possible
-destructor properly cleans up

===TASK===--------DONE
TerrainLayer, by default use size of qpixmap as size (instead of forcing it to be passed in ctor)

===TASK===----DONE
Go back through code and add QPointer/smart pointers where necessary
-if a class needs to reference something it doesn't own (shared) that its track ("following" somehow), QPointer so we can tell when what we are tracking is dead
-if class creates (owns) something, consider using unique_ptr so memory is automatically cleaned up
-fuctions should still take by raw pointer unless they will participate in ownership somehow (i.e. either own it, or be one of the owners (shared))
	
===TASK===----------DONE
Decide weather if we want Entities to own lifetime of all their EntityControllers.
pros:
-simpler lifetime management, just create lots and lots of EntityControllers without worrying about deleting them (they'll be deleted when the Entity dies)
cons:
-none, but the unique ptr approach i'm taking right now is wrong. I should use Qt's parent/child system to handle the lifetime.

===TASK===
Use Qt's parent/child system to enforce 'container/contained lifetime ownership policy'
-do this for Entity/EntityControllers - DONE
-do this for entity and sprite - DONE

===TASK===--------DONE
Add an ability to specify location of an entity's sprite relative to the entity
|
V
EntitySprite::setPos() should set the position of the EntitySprite relative to its entity.

===TASK===-------DONE
Change ECEnemyAttacker such that you give it a list of entities that the controlled entity should attack.
Change ECEnemyChaser too
-Get rid of the group system.

===TASK===---------DONE
ECBodyThruster/ECAttacker just don't appear to behave well. Fix.

start at the base, test fov emitter
-setFOVDebugging(true/false) -> 1) show field of view, emit messages when someone enters/leaves
-test and ensure correct behavior
	-when entity enters fov, enters messages should show and only once
	-when entity leaves fov, leaves message should show and only once
	*when any part of the "bounding box" of the entity enters it should do this
	
go up higher test ECChaser

go up higher test ECBodyThruster

go right (horizontally) test ECAttacker

===TASK===----DONE
Create z system
|
V
entities with lower y should be drawn higher
|
V
entities whos bottom of bounding box is lower should be drawn higher (greater z value)
|
V
plan
-on entity::setPos(), set z value to be w.e. bottom of boundingbox is

===TASK===-------DONE
Give trees a pathing map
|
V
Images should have a "channel" on which they can highlight parts that cannot be crossed
|
V
when importing, I can read that channel and draw polygons around those areas, then get a bbox around the polygon and "fill" that area

===TASK===---------DONE
MCSpawner* spawner = new MCSpanwer(map);
spawner->setRadius(900);
spawner->setSpawnType(MCSSpawner::SpawnType::Spider);
spawner->turnOn();
spawner->turnOff();


===TASK===----------DONE
Create some "creep" entities that will stand around	and attack enemies as they enter their line of sight.
|
V
-get some sprites for creeps - done (spider, goblin, etc..)
-create an Entity
-create an ECBodyThruster and attach it to the entity
-randomly spawn these entities in the map

===TASK===---------DONE
Make order of drawings (top to bottom):
-GUIs (later added -> topper)
-Entities (lower on screen -> topper)
-TerrainLayers (later added -> topper)

implementation
-entity z value is equal to bottom of bounding rects y (higher y draws on top) -> DONE
-make terrain z values start at -1000000 and subsequently added ones get incremented
    -ensure no more than 1000000 terrains are ever added
-make gui z values start at some number so large no map will ever be that large 
    -lets say start at 1000000
    -keep increasing as they are added

===TASK===----------DONE
Play sound when minitaur attacks
-make sound settable for AnimationAttack

===TASK===------DONE
Make spider play death animation before dying.

===TASK===-----DONE
Experiment/play with the idea of 'adding' sound to animations.
-Not a good idea, they should remain decoupled.
-a better idea might be to give each entity a collection of string:PositionalSounds
    -e.g. die:PositionalSound, hit:PositionalSound
    -these sounds get played when the entity gets hit or die

Interface
    Entity* e; // assume e points to a valid entity
    e->addSound("hit","qrc:/resources/sounds/hit.wav");
    e->addSound("die,"qrc:/resources/sounds/die.wav");
    e->play("hit",1); // play sound "hit" one time

implementation of addSound():
    sounds_["hit"] = "qrc:/resources/sounds/hit.wav";

implementation of play()
    assert(map() != nullptr)
    if (soundStrToPS[str].find() == end())
        soundStrToPS = new PositionalSound(map(),"path", QPointF());
    s->setPos(pos()); // set pos of sound to pos of entity
    s->play() // play it

===TASK===-------DONE
Create a health potion item.
-its use() should simply give the owner some health

===TASK===
Have creeps drop items
|
V
dream interface
    CItemDropper* itemDropper = new CItemDropper(); // C = controller, so "Controller ItemDropper"
    itemDropper->addEntity(e1);
    itemDropper->addEntity(e2);

===TASK===------DONE
Show health bar above spiders.

===TASK===---------DONE
Spiders do not damage player, fix.

Spiders use BodyThrust ability, when spider does collision test on its path, no entities are returned.

=============================================================================
=============================================================================
=========================UNFINISHED TASKS====================================
=============================================================================
=============================================================================

===Task===
Add a entity that will talk to you.
|
v
Creat a ECDialogShower entity that will pop a dialog whenever 'entities of interest' comes within some distance of the controlled entity.
|
V
dream api:
DialogGui* dg; // assume dialog gui is prepared with choices/respones
ECDialogShower* ds = new ECDialogShower(e); // e is an Entity*
ds->addEntityOfInterest(e1); // when e1 gets near e show the gui
ds->addEntityOfInterest(e2); // when e1 or e2 gets near e show the gui
ds->setDistance(100);

    ===TASK===
    Have ECDialogShower listen to when controlled entity dies and in response, make sure dialog gui isn't showing
        - make EntityController listen to when controlled entity dies, and in response call virtual function onControlledEntityDies (default impl does nothing)

===TASK===
Add a shop entity.
|
v
Create a ECShopShower entity that will pop up 

===TASK===
IMPORTANT - work on THIS task only (while doing it, you will discover new things to do)
Create youtube tutorial that creates a *basic game*
- WORKING - DONE - player controlled entity (grabs cam and can go to other maps) - have all necessary tools  
- WORKING - DONE -creep entities (will chase/attack enemies w/i their line of sight) - have all necessary tools
- WORKING - DONE -creeps drop items (health, GoldItem, Weapons, NoTargetItem, TargetItem, etc...) - have all necessary tools
- WORKING - DONE -creeps respawn - have all necessary tools
-player keeps killing creeps, thus keeps getting new items - have all necessary tools
-there is a small "town" with some npcs (shop and quest giver) - have all necessary tools (use watched-watching sys to keep track of when playing entity comes near shop or quest giver)
-shop entity can sell you weapons in exchange for GoldItem - can show in tut how to make the ShopGuiBehavior
-quest giver has a few quests such as "kill 10 x", when completed, you get bonus gold - can connect to when quest completed, spawn gold coin at loc of player



























